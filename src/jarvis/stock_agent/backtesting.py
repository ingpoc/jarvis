"""Backtesting framework for trading strategy validation.

Provides a simple event-driven backtester that:
1. Replays historical price data
2. Executes strategy rules at each bar
3. Tracks positions, P&L, and performance metrics
4. Generates summary reports

Strategies are defined as classes with an `on_bar` method.
"""

from __future__ import annotations

import logging
import math
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Protocol

logger = logging.getLogger(__name__)


class Side(Enum):
    BUY = "buy"
    SELL = "sell"


@dataclass
class Trade:
    """A single trade execution."""
    timestamp: str
    side: Side
    price: float
    quantity: float
    value: float  # price * quantity
    reason: str = ""


@dataclass
class Position:
    """Current portfolio position."""
    symbol: str
    quantity: float = 0.0
    avg_cost: float = 0.0
    unrealized_pnl: float = 0.0

    @property
    def is_open(self) -> bool:
        return self.quantity != 0

    def update_price(self, price: float) -> None:
        if self.quantity > 0:
            self.unrealized_pnl = (price - self.avg_cost) * self.quantity
        elif self.quantity < 0:
            self.unrealized_pnl = (self.avg_cost - price) * abs(self.quantity)


@dataclass
class Bar:
    """A single price bar (OHLCV)."""
    date: str
    open: float
    high: float
    low: float
    close: float
    volume: int


@dataclass
class BacktestResult:
    """Results of a completed backtest."""
    strategy_name: str
    symbol: str
    start_date: str
    end_date: str
    initial_capital: float
    final_value: float
    total_return_pct: float
    annualized_return_pct: float
    max_drawdown_pct: float
    sharpe_ratio: float
    total_trades: int
    winning_trades: int
    losing_trades: int
    win_rate: float
    avg_win: float
    avg_loss: float
    profit_factor: float
    trades: list[Trade]
    equity_curve: list[float]

    def to_dict(self) -> dict:
        return {
            "strategy": self.strategy_name,
            "symbol": self.symbol,
            "period": f"{self.start_date} to {self.end_date}",
            "initial_capital": self.initial_capital,
            "final_value": round(self.final_value, 2),
            "total_return_pct": round(self.total_return_pct, 2),
            "annualized_return_pct": round(self.annualized_return_pct, 2),
            "max_drawdown_pct": round(self.max_drawdown_pct, 2),
            "sharpe_ratio": round(self.sharpe_ratio, 3),
            "total_trades": self.total_trades,
            "winning_trades": self.winning_trades,
            "losing_trades": self.losing_trades,
            "win_rate": round(self.win_rate, 2),
            "avg_win": round(self.avg_win, 2),
            "avg_loss": round(self.avg_loss, 2),
            "profit_factor": round(self.profit_factor, 2),
        }


class Strategy(Protocol):
    """Protocol for backtesting strategies."""
    name: str

    def on_bar(self, bar: Bar, position: Position, context: StrategyContext) -> list[Signal]: ...


@dataclass
class Signal:
    """A trading signal generated by a strategy."""
    side: Side
    quantity: float = 1.0
    reason: str = ""


@dataclass
class StrategyContext:
    """Context available to strategies during backtesting."""
    bars_history: list[Bar]
    current_bar_index: int
    cash: float
    equity: float
    position: Position

    @property
    def closes(self) -> list[float]:
        return [b.close for b in self.bars_history[:self.current_bar_index + 1]]

    @property
    def highs(self) -> list[float]:
        return [b.high for b in self.bars_history[:self.current_bar_index + 1]]

    @property
    def lows(self) -> list[float]:
        return [b.low for b in self.bars_history[:self.current_bar_index + 1]]

    @property
    def volumes(self) -> list[int]:
        return [b.volume for b in self.bars_history[:self.current_bar_index + 1]]


class BacktestEngine:
    """Event-driven backtesting engine.

    Usage:
        engine = BacktestEngine(initial_capital=10000)
        result = engine.run(strategy, bars)
    """

    def __init__(self, initial_capital: float = 10000.0, commission: float = 0.001):
        self.initial_capital = initial_capital
        self.commission = commission  # As fraction (0.001 = 0.1%)

    def run(
        self,
        strategy: Strategy,
        bars: list[Bar],
        symbol: str = "UNKNOWN",
    ) -> BacktestResult:
        """Run a backtest with the given strategy and data.

        Args:
            strategy: Strategy instance with on_bar method
            bars: List of OHLCV bars (chronological order)
            symbol: Stock ticker symbol

        Returns:
            BacktestResult with performance metrics
        """
        if len(bars) < 2:
            raise ValueError("Need at least 2 bars for backtesting")

        cash = self.initial_capital
        position = Position(symbol=symbol)
        trades: list[Trade] = []
        equity_curve: list[float] = []

        for i, bar in enumerate(bars):
            # Update position value
            position.update_price(bar.close)
            equity = cash + (position.quantity * bar.close)
            equity_curve.append(equity)

            # Get strategy signals
            context = StrategyContext(
                bars_history=bars,
                current_bar_index=i,
                cash=cash,
                equity=equity,
                position=position,
            )

            try:
                signals = strategy.on_bar(bar, position, context)
            except Exception as e:
                logger.warning(f"Strategy error at bar {i}: {e}")
                signals = []

            # Execute signals
            for signal in signals:
                if signal.side == Side.BUY:
                    cost = bar.close * signal.quantity * (1 + self.commission)
                    if cost <= cash:
                        cash -= cost
                        if position.quantity == 0:
                            position.avg_cost = bar.close
                        else:
                            total_qty = position.quantity + signal.quantity
                            position.avg_cost = (
                                (position.avg_cost * position.quantity + bar.close * signal.quantity)
                                / total_qty
                            )
                        position.quantity += signal.quantity
                        trades.append(Trade(
                            timestamp=bar.date,
                            side=Side.BUY,
                            price=bar.close,
                            quantity=signal.quantity,
                            value=cost,
                            reason=signal.reason,
                        ))

                elif signal.side == Side.SELL:
                    sell_qty = min(signal.quantity, position.quantity)
                    if sell_qty > 0:
                        proceeds = bar.close * sell_qty * (1 - self.commission)
                        cash += proceeds
                        position.quantity -= sell_qty
                        if position.quantity == 0:
                            position.avg_cost = 0
                        trades.append(Trade(
                            timestamp=bar.date,
                            side=Side.SELL,
                            price=bar.close,
                            quantity=sell_qty,
                            value=proceeds,
                            reason=signal.reason,
                        ))

        # Final equity
        final_equity = cash + (position.quantity * bars[-1].close)
        equity_curve[-1] = final_equity

        # Calculate metrics
        return self._calculate_metrics(
            strategy_name=strategy.name,
            symbol=symbol,
            bars=bars,
            trades=trades,
            equity_curve=equity_curve,
            initial_capital=self.initial_capital,
            final_value=final_equity,
        )

    def run_from_dict_data(
        self,
        strategy: Strategy,
        data: list[dict],
        symbol: str = "UNKNOWN",
    ) -> BacktestResult:
        """Run a backtest from dict data (e.g., from yfinance MCP).

        Args:
            strategy: Strategy instance
            data: List of dicts with date, open, high, low, close, volume
            symbol: Stock ticker

        Returns:
            BacktestResult
        """
        bars = [
            Bar(
                date=d["date"],
                open=d["open"],
                high=d["high"],
                low=d["low"],
                close=d["close"],
                volume=d["volume"],
            )
            for d in data
        ]
        return self.run(strategy, bars, symbol)

    def _calculate_metrics(
        self,
        strategy_name: str,
        symbol: str,
        bars: list[Bar],
        trades: list[Trade],
        equity_curve: list[float],
        initial_capital: float,
        final_value: float,
    ) -> BacktestResult:
        """Calculate performance metrics from backtest results."""
        total_return = (final_value / initial_capital - 1) * 100

        # Annualized return (assume 252 trading days)
        n_bars = len(bars)
        years = n_bars / 252 if n_bars > 0 else 1
        ann_return = ((final_value / initial_capital) ** (1 / max(years, 0.01)) - 1) * 100

        # Max drawdown
        max_dd = 0.0
        peak = equity_curve[0]
        for eq in equity_curve:
            if eq > peak:
                peak = eq
            dd = (peak - eq) / peak * 100
            if dd > max_dd:
                max_dd = dd

        # Daily returns for Sharpe
        daily_returns = []
        for i in range(1, len(equity_curve)):
            if equity_curve[i - 1] > 0:
                daily_returns.append(equity_curve[i] / equity_curve[i - 1] - 1)

        if daily_returns:
            avg_return = sum(daily_returns) / len(daily_returns)
            variance = sum((r - avg_return) ** 2 for r in daily_returns) / len(daily_returns)
            std_return = math.sqrt(variance) if variance > 0 else 0.001
            sharpe = (avg_return / std_return) * math.sqrt(252)
        else:
            sharpe = 0.0

        # Trade analysis
        trade_pnls: list[float] = []
        i = 0
        while i < len(trades) - 1:
            if trades[i].side == Side.BUY:
                # Find matching sell
                for j in range(i + 1, len(trades)):
                    if trades[j].side == Side.SELL:
                        pnl = (trades[j].price - trades[i].price) * min(trades[i].quantity, trades[j].quantity)
                        trade_pnls.append(pnl)
                        break
            i += 1

        wins = [p for p in trade_pnls if p > 0]
        losses = [p for p in trade_pnls if p <= 0]

        win_rate = len(wins) / len(trade_pnls) * 100 if trade_pnls else 0
        avg_win = sum(wins) / len(wins) if wins else 0
        avg_loss = sum(losses) / len(losses) if losses else 0
        gross_profit = sum(wins)
        gross_loss = abs(sum(losses))
        profit_factor = gross_profit / gross_loss if gross_loss > 0 else float('inf') if gross_profit > 0 else 0

        return BacktestResult(
            strategy_name=strategy_name,
            symbol=symbol,
            start_date=bars[0].date if bars else "",
            end_date=bars[-1].date if bars else "",
            initial_capital=initial_capital,
            final_value=final_value,
            total_return_pct=total_return,
            annualized_return_pct=ann_return,
            max_drawdown_pct=max_dd,
            sharpe_ratio=sharpe,
            total_trades=len(trades),
            winning_trades=len(wins),
            losing_trades=len(losses),
            win_rate=win_rate,
            avg_win=avg_win,
            avg_loss=avg_loss,
            profit_factor=profit_factor,
            trades=trades,
            equity_curve=equity_curve,
        )


# --- Built-in Example Strategies ---

class SMAcrossover:
    """Simple Moving Average Crossover strategy.

    Buys when fast SMA crosses above slow SMA, sells on cross below.
    """
    name = "SMA Crossover"

    def __init__(self, fast_period: int = 10, slow_period: int = 30):
        self.fast_period = fast_period
        self.slow_period = slow_period

    def on_bar(self, bar: Bar, position: Position, context: StrategyContext) -> list[Signal]:
        closes = context.closes
        if len(closes) < self.slow_period:
            return []

        fast_sma = sum(closes[-self.fast_period:]) / self.fast_period
        slow_sma = sum(closes[-self.slow_period:]) / self.slow_period

        prev_closes = closes[:-1]
        if len(prev_closes) < self.slow_period:
            return []

        prev_fast = sum(prev_closes[-self.fast_period:]) / self.fast_period
        prev_slow = sum(prev_closes[-self.slow_period:]) / self.slow_period

        signals = []

        # Golden cross: fast SMA crosses above slow SMA
        if prev_fast <= prev_slow and fast_sma > slow_sma and not position.is_open:
            qty = int(context.cash * 0.95 / bar.close)
            if qty > 0:
                signals.append(Signal(Side.BUY, qty, "Golden cross"))

        # Death cross: fast SMA crosses below slow SMA
        elif prev_fast >= prev_slow and fast_sma < slow_sma and position.is_open:
            signals.append(Signal(Side.SELL, position.quantity, "Death cross"))

        return signals


class RSIMeanReversion:
    """RSI Mean Reversion strategy.

    Buys when RSI < 30 (oversold), sells when RSI > 70 (overbought).
    """
    name = "RSI Mean Reversion"

    def __init__(self, rsi_period: int = 14, oversold: float = 30, overbought: float = 70):
        self.rsi_period = rsi_period
        self.oversold = oversold
        self.overbought = overbought

    def on_bar(self, bar: Bar, position: Position, context: StrategyContext) -> list[Signal]:
        closes = context.closes
        if len(closes) < self.rsi_period + 1:
            return []

        from jarvis.stock_agent.technical_indicators import TechnicalIndicators
        rsi_result = TechnicalIndicators.rsi(closes, self.rsi_period)
        latest_rsi = rsi_result.values[-1]

        if latest_rsi is None:
            return []

        signals = []

        if latest_rsi < self.oversold and not position.is_open:
            qty = int(context.cash * 0.95 / bar.close)
            if qty > 0:
                signals.append(Signal(Side.BUY, qty, f"RSI oversold ({latest_rsi:.1f})"))

        elif latest_rsi > self.overbought and position.is_open:
            signals.append(Signal(Side.SELL, position.quantity, f"RSI overbought ({latest_rsi:.1f})"))

        return signals
